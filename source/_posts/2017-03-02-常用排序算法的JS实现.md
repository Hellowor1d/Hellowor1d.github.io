---
title: 常用排序算法的JS实现
date: 2017-03-02 11:40:29
subtitle:
header-img:
tags:
- JavaScript
- Algorithms
---
## 排序算法说明

**时间复杂度**: 一个算法执行所耗费的时间

**空间复杂度**: 运行完一个程序所需内存的大小

假如存在一个data为数组[9,5,8,7,5,6,2,3,4,0]，想对其进行排序，最方便的可以使用js自身的sort方法，比如：
```JavaScript
var data =[9,5,8,7,5,6,2,3,4,0]
// 想对该数组进行排序，可以使用js自带的sort方法:
data.sort((x,y)=>x-y)
```
但是为了学习其他排序算法的思路，我们也分别用其他方法进行对比
### 1.冒泡排序
思路解析：
重复比较相邻两个元素之间的大小，小的放左边，大的放右边。
第一轮比较之后，最大的数值肯定会被放到最右边。
接下来第二轮，只需要把第二轮中最大的放在第二靠右的位置就行了，所以j的限定范围是j<len-1-i
以此类推：
```js
Array.prototype.bubbleSort = function(){
    var len = this.length
    var arr = this
    for(var i=0; i<len-1;i++){
        for(var j=0; j<len-i-1; j++){
            if(arr[j]>arr[j+1]){
                var temp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1]=temp
            }
        }
    }
    return arr
}
console.log(data.bubbleSort())  //[0,2,3,4,5,5,6,7,8,9]

```
### 2.快速排序
思路解析：快速排序是对冒泡排序的一种改进，第一轮排序将数据分为两部分，一部分比另一部分的所有数据都小。
接着再对两个部分递归调用快排方法，直到最小的部分只剩两个元素。
(1)选择一个基准元素，将数据分为两个子序列；
(2)对数据重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的数据放在后面；
(3)分别对较小元素的子序列和较大元素的子序列重复（1）（2）两个步骤
```js
Array.prototype.quickSort = function(){
    var arr = this,len = arr.length
    if(len<=1){
        return arr
    }
    var pivotIndex = Math.floor(len/2)
    var pivot = arr.splice(pivotIndex,1)[0] //基准值
    var left=[],right=[]
    for(var i=0; i<len-1; i++){
        if(arr[i]<pivot){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return left.quickSort().concat([pivot],right.quickSort())
}
console.log(data.quickSort())  //[0,2,3,4,5,5,6,7,8,9]
```
